---
published: true
layout: post
title: Question marks inside black diamonds
---
Навеяно дискуссиями в группе...

*Саша*. Недавно я пытался локализовать контент приложения. И столкнулся с интересной ситуацией. Вместо подходящего символа в кириллице я увидел знаки вопроса.

*Паша*. Ты наверное слышал про кодировки и все такое.

*Саша*. Слышал. И пытался читать файл различными кодировками. Но все без толку. А ведь в документации к плагину сказано, что для чтения файлов используется кодировка UTF-8. То есть по идее плагин должен читать любой Unicode-символ.

*Паша*. Подозреваешь, что плагин не справляется с это задачей?

*Саша*. Читать-то он может и читает. Но вот с отображением текста беда. Ради интереса попробовал создать новый файл и руками накодировал Unicode:

> \u043a\u0440\u0430\u043a\u043e\u0437\u044f\u0431\u0440\u044b \u0432\u043e\u043d

*Петя*. Надо же, 'кракозябры вон' 'накодировал'.

*Саша*. Но знаки вопроса и вправду исчезли! А плагин прочитал и нормально отобразил содержимое.
Но это же не значит, что мне любой текст нужно таким образом кодировать?

*Маша*. Это значит, что термин "кодирование" вызывает у тебя некоторую путаницу. Услышу, что путаешь, заставлю учить code points наизусть. В рамках Unicode кодирование происходит дважды. Первый раз кодируется набор символов Unicode (UnicodeCharacterSet).

*Даша*. А помните, Пол нам рассказывал, что Unicode позволяет представить символы всех языков мира, потому что каждому Unicode-символу ставится в соответствие code point.

*Маша*. В рамках этого процесса мы получаем coded character set. Во второй раз последовательность
Unicode-символов преобразуется в строку байтов.

*Саша*. И надо же, этот процесс тоже называется 'кодирование'.

*Маша*. В англоязычной терминологии существуют два разных глагола - to code и to encode. К тому же часто термин character set используется в качестве синонима к coded character set.

*Саша*. Звыняйтэ, я щэ нэ настилькы английською володию.

*Маша*. Это я к тому, чтобы ты различал ситуации, когда речь идёт о code point Unicode-символа, а когда - о его байтовом представлении.

*Саша*. Так вот почему плагин смог правильно прочитать файл с Unicode-поинтами! Все дело в байтах.

*Паша*. Удивляет, но тебя это удивляет.

*Саша*. Но так тест писать костыльно. Ладно, если дело касается одной-двух строк. Но нельзя же сотни строк в кодировке Unicode прописывать.

*Маша*. Отсюда можно сделать вывод, что ты не понимаешь, что такое Unicode, потому что Unicode - это вовсе не кодировка. Ведь code point - это теоретическая концепция.

*Паша*. И у каждой концепции, как обычно, есть техническая сторона.

*Маша*. А вот как code point представлен в памяти - это уже техническая сторона вопроса.

*Саша*. Насколько понимаю, за это отвечают различные кодировки. Но почему нет единой универсальной кодировки?

*Маша*. Так сложилось исторически. До появления Unicode для поддержки различных языков использовались различные кодовые страницы. Иначе говоря таблицы, сопоставляющие каждому значению байта некоторый символ. Однако кодовая страница может содержать максимум 256 символов. Иначе говоря, символ был однобайтным.

*Саша*. Видимо, отсюда и появились проблемы неправильной раскодировки и ограниченного набора символов.

*Маша*. Потом появился Unicode.

*Даша*. А Пол говорил, что появление Unicode дало возможность легко обмениваться данными на разных языках.

*Маша*. А вместе с Unicode появились и семейства кодировок (Unicode Transformation Format). Стандарт включает в себя описание ряда кодировок, например UTF-8, UTF-16BE/UTF-16LE, UTF-32, которые позволяют кодировать всё пространство code points. Конвертация между этими кодировками может свободно осуществляться без потерь информации. Самой распространённой из них является UTF-8, благодаря её экономичности и совместимости с семибитной ASCII. Латинские и служебные символы, основные знаки препинания и цифры — т.е. все символы семибитной ASCII — кодируются в UTF-8 одним байтом, тем же, что и в ASCII. Символы многих основных письменностей представлены в ней двумя или тремя байтами. UTF-8 — это кодировка с переменной длиной кода. Число в конце кодировки означает битовую длину кодовой единицы. Кодировка определяет, сколько кодовых единиц нужно для кодирования символа.

*Саша*. Но если UTF-кодировки решают многие проблемы, то почему они используются не повсеместно,
а кодовые страницы существуют до сих пор?

*Маша*. Файлы нелатинских символов в UTF-кодировках всегда занимают больше места, так как один
символ кодируется не одним байтом. И хотя с удешевлением памяти и дискового пространства проблема становится менее существенной, списывать со счета ее не стоит. Особенно если речь идет о большом количестве текста. К тому же при использовании UTF-кодировок производительность программ обработки текста снижается.

*Витя*. Представляю `радость` супруги, узнавшей, что мой новый комп обойдется на 25% дороже из-за
того, что новая операционная система требует гораздо больше памяти и вычислительных ресурсов, но позволяет без проблем работать с письмом чероки, символами западной и византийской музыки, клинописью, монгольским квадратным письмом и письмом пахау.

*Петя*. Тем не менее большинство современных операционных систем в той или иной степени обеспечивает поддержку Unicode, используя UTF-кодировки.

*Саша*. И при любой кодировке, текст всегда останется последовательностью чисел, то есть байт.

*Маша*. Которую нужно переводить на естественный язык с помощью таблиц, роль которых выполняют
кодовые таблицы. Неверная таблица – неверный символ. Поэтому участники, передающие информацию,
всегда должны указывать кодировку.

*Саша*. Получается, мне нужно знать, какая таблица, иначе говоря, какая кодировка использовалась для записи моего текста.

*Маша*. Если твой текст сохранился в другой кодировке, а ты попытался прочитать его как UTF-8, неудивительно, что появились вопросительные знаки. Декодер, не увидел смысла в числах, которые прочитал. Если прочитанное число находится в последовательности до 191, то это ASCII код, а если за ее пределами, то нужно читать дальше. Так, если декодер UTF-8 видит числа 195-245, то он понимает, что находится в начале многобайтовой последовательности, а если 132-191, он занет, что находится в однобайтовой последовательности. Это значит, что последовательность 191-244 декодер
не пропустит, потому что не будет знать, что с ней делать. И ты увидишь знаки вопроса.

*Саша*. То есть в моем случае надо было проверить, в какой кодировке записывается текст, и настроить ее на UTF-8. Потому что мы не работаем с текстом напрямую. Под капотом мы работаем с
числами, то есть байтами, которые обернуты в абстракцию. С абстракциями и связаны ошибки.

*Паша*. Вот это сказал! Даша, возьми на заметку.

*Маша*. Когда вновь испортишь текст, оправдания не помогут. Вопросы мы вроде все разобрали.

*Саша*. Пожалуй один еще остался. Петя, а каким образом ты code points наизусть знаешь?

> Все герои вымышлены, полное или частичное сходство является совпадением.
