	Навеяно дискуссиями о шаблоне в группе...
    
	Саша. Хорошо, Model-View-Presenter позволяет абстрагировать пользовательский интерфейс от логики приложения для того, чтобы ...

	Маша. Чтобы поведение приложения не зависело от его конкретного внешнего вида.

	Саша. Давай на примере.
 
	Маша. Например, под разной торговой маркой может прятаться один и тот же продукт. Продукт - это как бы модель, а его упаковка - это представление.

	Витя. Есть идея по выполнению домашки. Давайте коллективными усилиями реализуем логику калькулятора в модели, а вьюшки - каждый свою прикрутит.

	Маша. Думаешь, прокатит? 
	
	Даша. Зато сразу раскрываются возможности шаблона. Вот, написала команда какое-то чудо-приложение, тестами код покрыла, выяснила, что все классно работает. А приложение-то не продается. 
И тут маркетологи сообщают, что причина кроется в отвратительном внешнем виде приложения. 

	Маша. Вьюшка видимо никуда не годится.

	Даша. И как такой ужас вообще можно потребителю предлагать? Дизайнер получает нагоняй, после чего вьюшку заменяет на супер-вьюшку, со всеми этими дизайнерскими штучками, - и уровень продаж стремительно растет.

	Петя. Вот так просто взяли и заменили?

	Саша. Просто заменили. Презентер работает с интерфейсом вьюшки. Какую вьюшку не подставь, главное, чтобы она реализовала интерфейс, через который презентер будет обновлять данные. Вот тебе и принцип Inversion of Control (он же Dependency Injection у Фаулера). И вся соль проектирования интерфейсами. Мы не хотим знать, как что-то происходит, мы можем просто сделать заглушку, которая будет на момент разработки возвращать то, что нам нужно.

	Даша. Смотрите, если задача презентера - получить действие пользователя и передать его в модель, а затем передать изменение состояния модели во вьюшку, получается, что презентер - просто прослойка. Может тогда стоит разместить код вызова соответствующих методов в представлении?

	Маша. Ну да, и превратить архитектуру SOLID в архитектуру STUPID. В частности, у представления
появится еще одна обязанность - логика управления моделью.

	Саша. Чего это? 

	Маша. Того, что представление будет заниматься интерпретацией пользовательского ввода, чтобы определить, какой метод вызвать у модели, а это нарушит принцип единой ответственности.

	Витя. Ну да, если разобраться, то презентер не просто передает данные в модель и представление. Он отвечает за интерпретацию ввода для вызова соответствующих методов модели. Вот нажимает пользователь кнопку, презентер передает данные на обработку модели. Внутри модели что-то
происходит или не происходит. Когда презентер получает уведомление от модели о том, что результат обработки можно забрать, он определяет, какое свойство считать у модели, и какому свойству вьюшки его присвоить. 

	Маша. Получается, свойства, измененные моделью, должны быть реализованы в представлении. иначе говоря входной интерфейс представления соответствует выходному интерфейсу модели.
    
    Петя. Модель тоже может реализовать интерфейс, через который презентер будет с ней работать. На случай если разработчику нужно будет подправить реализацию.


	В результате дискуссии вот какие заметки получились у студентов, разрабатывающих приложение калькулятор.
    
    Создается интерфейс представления с определенным набором свойств и методов.
    
IView
event EventHandler<SomeType> OperandPressed;
event EventHandler<SomeType> OperatorPressed;
UpdateOperand(string value);
UpdateExpression(string value);

    А также интерфейс модели.
IModel
event EventHandler<YourType> OperandChanged;
event EventHandler<YourType> ExpressionChanged;
Operand{get;}
Expression{get;}

	Пользователь взаимодействует с представлением(1). Презентер, получивший ссылку на реализацию интерфейса, подписывается на события представления и по запросу изменяет модель(2). Когда и если в модели что-то меняется, она уведомляет об этом презентера(3), который вызывает соответствующий метод обновления у представления(4). 

1.  View : IVew
    public event EventHandler<Operand> OperandPressed;
    ...
    private void OnDigit2Clicked(object sender, EventArgs e)
    {
        OperandPressed?.Invoke(this, new Operand("2"));
    }
    
2. Presenter
   ...
   private void View_OperandPressed(object sender, OperandPressed args)
   {
       if (args == null) return;
       _model.AppendOperand(args.Value);
   }

3. Model : IModel
   ...
   public event EventHandler<Operand> OperandChanged;
   public string Operand
   {
       get => _backingField;
       private set
       {
           _backingField = value;
           OnOperandChanged();
       }
   }
   
   private void OnOperandChanged()
   {
       OperandChanged?.Invoke(this, new Operand("2"));
   }
   
6. Presenter
   ...
   private void Model_OperandChanged(object sender, Operand args)
   {
       if (args == null) return;
       _view.UpdateOperand(args.Value);
   }
   

	P.S. Упомянутые студенты дискутировали о базовой версии шаблона (Passive View), однако известны несколько вариантов ее модификации. Например, Presentation Model, Supervising Controller и Passive View. Все они отличаются исключительно способом взаимодействия Презентера и Представления, а точнее способами передачи данных представлению.
