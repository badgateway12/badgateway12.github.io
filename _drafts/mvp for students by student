
Первое, что следует сказать о шаблоне проектирования MVP, - это не шаблон приложения,
это паттерн для построения пользовательского интерфейса, абстрагирования представления,
но вполне может и не быть единственном паттерном приложения.

НеГлупые вопросы.
1. И зачем это нужно?
-  Это нужно чтобы поведение приложения не зависело от его конкретного внешнего вида.
2. И все-таки зачем?
- Ну например затем, что под разной торговой маркой может прятаться один и тот же продукт.
Допустим, студентам компьютерной академии задали написать в качестве домашнего задания приложение
калькулятор. И появилась такая идея. Коллективными усилиями реализовать логику калькулятора,
а вьюшку каждому свою прикрутить.
3. И что, прокатило?
- Следующий раз не прокатит.
А если серьезно, давайте представим ситуацию. Ну, написала команда какое-то чудо-приложение,
и тестами код покырла, и выяснила, что работет все классно. Да вот не продается приложение.
И тут маркетологи сообщаю, что причина кроется в отвартительном внешнем виде приложения.
Как такой ужас вообще можно потребителям предлагать? И получил дизайнер нагоняй, и это его ддохновило,
и нарисовал он супер-представление, и взлетел уровень продаж. Как-то так.

Теперь о компонентах паттерна.
Модель. Она содержит информацию о состоянии, данных и логике работы приложения, она
является точкой доступа к данным и логике приложения.
Представление. Оно отвечает за отображение состояния модели.
Презентер. Презентер берёт на себя функциональность посредника, двухстороннего диспетчера,
отвечая за управление событиями представления.

Вот как знакомые нам студенты изобразили паттерн MVP для приложения калькулятор.
Пользователь взимодействует с моделью через представление (1), в результате этого действия
презентер через механизм событий (подключается паттерн наблюдатель), получает уведомление от
представления (2), определяет его смысл и обращается к модели с запросом об изменении состояния,
вызывая соответствующий метод(3) у модели. Когда и если в модели что-то меняется(4), она через механизм
событий уведомляет об этом презентера(5), который вызывает соответствующий метод обновления
состояния у представления(6).

НеГлупые вопросы.
Диалог разработчиков компьютерной академии.

Жанна. Если задача  презентера - получить действие пользователя и передать его в модель,
а затем передать изменения модели в представление, получается его работа сводится к вызову метода
модели и вызову метода представления. Презентоер - просто прослойка. Может тогда стоит
разместить код вызова соответствующих методов в представлении?

Даша.
Ну да, тогда архитеркура SOLID превратится в архитектуру STUPID. В частности, у представоления
появится еще одна обязанность - логика управления моделью, раз представление будет заниматься
интерпретации пользовательского ввода, чтобы определить, какой метод у модели вызвать, а это
нарушит принцип Single Responsibility.

Маша. Ну да, если разобраться, то презентер не просто передает данные в модель и представление.
Он отвечает за интерпретацию ввода для вызова соответствующих методов. Нажимает пользователь в
представлении кнопку, презентер передает данные на обработку модели. Внутри моели что-то
происходит. Когда презентер получает уведомление от модели о том, что результат обработки можно забрать,
по событию он определяет, которое свойство считать у модели, и которому свойству его присвоить в
представлении. Нажата кнопка с цифрой два, модель после некоторой обработаки данных, определяет,
что это изменился операнд, уведомлет об изменении, презентер считывает свойство "операнд",
и присваивает обновленные данные представлению. Если затем пользователь нажимает кнопку плюс, модель
может, например, определить, что речь идет об арифметическом выражении, и изменить состояние выражения,
и тогда презентер присвоит обновленные данные уже не операнду, а выражению.

Жанна. Получается, свойства, измененные моделью, должны быть реализованы в представлении. иначе говоря
входной интерфейс представления соответствует выходному интерфесу модели.

Даша. И раз уж мы говорим об архитертуре SOLID, то представление просто обязано реализовать
интерфейс для отображения данных, в противном случае нарушим DIP-принцип, ведь представление - это модуль
верхнего уровня, а модули верхнего уровня не должны зависеть от модулей нижнего уровня, т.е. представление
не должно зависеть от представления.
