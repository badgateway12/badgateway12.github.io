Навеяно дискуссиями о шаблоне в группе...

Саша. Хорошо, Model-View-Presenter позволяет абстрагировать пользовательский интерфейс от логики приложения, чтобы ...

Маша. Чтобы поведение приложения не зависело от его конкретного внешнего вида.

Саша. Давай на примере.

Маша. Например, под разной торговой маркой может прятаться один и тот же продукт. Продукт - это как бы Модель, а его упаковка - это Представление.

Витя. Есть идея по выполнению домашки. Давайте коллективными усилиями реализуем логику калькулятора в Модели, а вьюшки - каждый свою прикрутит.

Маша. Думаешь, прокатит?

Даша. Зато сразу раскрываются возможности шаблона. Вот, написала команда какое-то чудо-приложение, тестами код покрыла, выяснила, что все классно работает. А приложение-то не продается.
И тут маркетологи сообщают, что причина кроется в отвратительном внешнем виде приложения.

Маша. Вьюшка видимо никуда не годится.

Даша. И как такой ужас вообще можно потребителю предлагать? Дизайнер получает нагоняй, после чего вьюшку заменяет на супер-вьюшку, со всеми этими дизайнерскими штучками, - и уровень продаж стремительно растет.

Петя. Ага, вот так просто взяли и заменили.

Саша. Просто заменили. Презентер работает с интерфейсом вьюшки. Какую вьюшку не подставь, главное, чтобы она реализовала интерфейс, через который Презентер будет обновлять данные. Вот тебе и принцип Inversion of Control (он же Dependency Injection у Фаулера). И вся соль проектирования интерфейсами. И даже можно сделать заглушку, которая будет на момент разработки возвращать то, что нам нужно.

Даша. Смотрите, если задача Презентера - получить действие пользователя и передать его в Модель, а затем передать изменение состояния Модели во вьюшку, получается, что Презентер - просто прослойка. Может тогда стоит разместить код вызова соответствующих методов в Представлении?

Маша. Ну да, и превратить архитектуру SOLID в архитектуру STUPID. В частности, у представления
появится еще одна обязанность - логика управления моделью.

Саша. Чего это?

Маша. Того, что представление будет заниматься интерпретацией пользовательского ввода, чтобы определить, какой метод вызвать у модели, а это нарушит принцип единой ответственности.

Витя. Ну да, если разобраться, то Презентер не просто передает данные в Модель и Представление. Он отвечает за интерпретацию ввода для вызова соответствующих методов модели. Вот нажимает пользователь кнопку, Презентер передает данные на обработку Модели. Внутри модели что-то
происходит или не происходит. Когда Презентер получает уведомление от Модели о том, что результат обработки можно забрать, он определяет, какое свойство считать у Модели, и какому свойству вьюшки его присвоить.

Маша. Получается, свойства, изменяемые Моделью, должны быть реализованы в Представлении. Иначе говоря входной интерфейс Представления соответствует выходному интерфейсу Модели.

Петя. Модель тоже может реализовать интерфейс, через который Презентер будет с ней работать. На случай если разработчику нужно будет подправить реализацию.

Саша. Погодите с поправлением реализации. Давайте лучше определимся, что входит в обязанность Модели. Модель — это бизнес-логика приложения. Окей, логика калькулятора - считать. И тогда получается, что Модель калькулятора будет выполнять калькуляцию, то есть два плюс два складывать. А кто же тогда будет валидировать пользовательсикй ввод? Или раскидывать данные по операторам-операндам? Модель? Презентер?

Даша. А ты попробуй абстрагироваться. Модель - это бизнес-логика приложения. И если задача приложения - считать, то результат подсчета - это итог работы Модели. И мало ли что за подсчетом скрыто. То, что этому подсчету предшествуют валидация и парсинг - вполне нормально, и это как раз и есть бизнес-логика калькулятора.

Саша. А тебе не кажется, что это нарушение принципа единственной ответственности? Хотя куда валидацию ни прикрути, все равно появится еще одна ответственность.

Петя. Еще как кажется, особенно, если у тебя все в одном классе Модели будет сидеть. И валидация, и парсинг, и подсчет.

Маша. Вот именно. Если все в одном классе будет сидеть. Модель - ведь понятие абстрактное. За ней может стоять как просто слой данных, так и целая логика. Но не обязательно это все инкапсулировать в одном классе. Идея данного шаблона ведь в чем - отделить дизайн от логики работы приложения. Поэтому все, что не относится к прорисовке, отнесем к логике работы модели. А в самой модели никто не мешает придерживаться принципов SOLID и использоать другие шаблоны проектирования.

Саша. В итоге получаем пассивную вьюшку, "тонкого" Презентера, и максимум логики в Модели.

Машаю И минимум кода, который невозможно покрыть модульными тестами.

Вот какие заметки получились у студентов, воссоздающих стандартное приложение Калькулятор ОС Windows

IView
event EventHandler<SomeType> OperandPressed;
event EventHandler<SomeType> OperatorPressed;
UpdateOperand(string value);
UpdateExpression(string value);
...

IModel
event EventHandler<YourType> OperandChanged;
event EventHandler<YourType> ExpressionChanged;
Operand{get;}
Expression{get;}
...

Пользователь взаимодействует с Представлением(1). Презентер, получивший ссылку на реализацию интерфейса, подписывается на события Представления и по запросу изменяет Модель(2). Когда и если в Модели что-то меняется, она уведомляет об этом Презентера(3), который вызывает соответствующий метод обновления у Представления(4).

1. View : IVew
public event EventHandler<Operand> OperandPressed;
...
private void OnDigit2Clicked(object sender, EventArgs e)
{
OperandPressed?.Invoke(this, new Operand("2"));
}
...

2. Presenter
...
private void View_OperandPressed(object sender, OperandPressed args)
{
if (args == null) return;
_model.AppendOperand(args.Value);
}
...

3. Model : IModel
...
public event EventHandler<Operand> OperandChanged;
public string Operand
{
get => _backingField;
private set
{
_backingField = value;
OnOperandChanged();
}
}
...

private void OnOperandChanged()
{
OperandChanged?.Invoke(this, new Operand("2"));
}
...

6. Presenter
...
private void Model_OperandChanged(object sender, Operand args)
{
if (args == null) return;
_view.UpdateOperand(args.Value);
}
...

P.S. Все герои вымышлены, полное или частичное сходство является совпадением.